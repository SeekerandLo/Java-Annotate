## Lock

```java
public interface Lock{
    ...
}
```

### class
- Lock 的实现提供了比 synchorized 更多的锁操作和语句，它允许更加灵活的结构，可能内容完全不同，也可能支持多个对象

- Lock 是一个在多线程之间控制使用分享资源的工具。Lock 提供了**互斥存取**的共享资源的方式：在一个时间只有一个线程能够获取锁，所有的线程需要首先获得锁之后才能共享资源，然而有的锁可能允许并发访问共享资源，比如**读写锁**

- 使用 synchorized 的方法或者语句提供访问与每个对象相关联的**隐式监视器锁**，但是要强制使用代码块的方式执行锁的获取和释放，当多个锁被获得后，他们必须以相反的顺序进行释放，所有的锁必须释放在与他们被获得的相同词汇(**lexical**)范围内

- synchorized 方法和语句的范围界定使使用监视器锁编程变得容易，帮助避免了许多涉及到锁的常见编程错误，以下是一些你需要在更加灵活使用锁工作的场合，
有时一些算法需要并发访问数据结构，需要相间的或者锁住，你需要锁住节点A，然后是锁住B，再释放A，然后锁住C，再释放B，再锁住D等等。实现了 Lock 接口的实现能够允许锁获得和释放在不同的域中，允许多个锁去获得和释放以任意顺序

- Lock 更加灵活的性质带来了额外的操作，块结构锁(使用Lock的代码块)没有了使用 synchorized 的方法或语句自动释放锁的功能，常常以下面的形式使用：
    ```java
    Lock l = ...;
    l.lock();
    try {
      // 在锁的保护下访问资源
    } finally {
      l.unlock();
    }
    ```

- 当锁和释放锁在不同的范围中时，需要仔细确认是否代码执行时被保护在 try-finally 和 try-catch 以确保在必要的时候释放锁

- Lock 的实现比使用 synchorized 的方法和语句提供了额外的功能，提供了非阻塞的尝试获取锁方法(tryLock())去获得锁，能被中断的尝试获取锁的方法(lockInterruptibly())，能超时的尝试获取锁的方法(tryLock(long,TimeUnit))

- 一个 Lock 类可以提供行为和语义，这与隐式监视锁不同，比如保证有序，不可重入的使用，死锁检测。如果一些实现提供了特殊的语义，必须记录下来

- 需要注意 Lock 的实例只是普通对象，它们能够作为标签被使用在 synchorized 语句中。获取 lock 实例的监视器锁与调用该实例的任何 lock 方法没有指定的关系，为了避免混淆，建议不要使用这种方式使用 lock 的实例，除非是在它们自己的实现中

- 除了特殊说明外，任何一个值是 null，或者其他参数抛出空指针异常都会抛出

### methods

#### void lock()

- 如果锁不可用，则出于线程调度目的，当前线程将被禁用，并处于休眠状态，直到获取锁为止

- 一些实现可能导致锁的错误使用，比如导致死锁的情况，或者抛出异常的情况，这些需要在实现中记录

#### void lockInterruptibly()

- 获取锁，除非当前线程中断。获取锁，如果锁是可用的并且可以立即返回的

- 如果锁不可用，则出于线程调度目的，当前线程将被禁用，并处于休眠状态，直到出现下面两种情况为止
  - 锁被当前线程获取，或者其他线程中断当前线程**并且支持中断锁获取**[👉有问题，提issue](https://github.com/SeekerandLo/Java-Annotate/issues)
  - 如果当前线程：在进入此方法时设置了其中断状态；或者在获取锁时被中断，并且支持锁获取中断，则抛出 interruptedexception，并清除当前线程的中断状态

- 

#### boolean tryLock()

#### boolean tryLock(long,TimeUnit)

#### void unlock()

#### Condition newCondition()